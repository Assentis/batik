/*****************************************************************************
 * Copyright (C) The Apache Software Foundation. All rights reserved.        *
 * ------------------------------------------------------------------------- *
 * This software is published under the terms of the Apache Software License *
 * version 1.1, a copy of which has been included with this distribution in  *
 * the LICENSE file.                                                         *
 *****************************************************************************/

package org.apache.batik.svggen;

import java.awt.*;
import java.awt.geom.*;
import java.util.*;
import java.awt.font.*;

import org.w3c.dom.*;

/**
 * This class is used by the SVGGraphics2D SVG Generator to manage
 * addition of new Nodes to the SVG DOM Tree. This class handles
 * a set of DOMGroupManager objects that can all append to the
 * top level group managed by this class. This allows multiple
 * SVGGraphics2D instances, created from the same SVGGraphics2D
 * through the various create methods, to append to the same
 * SVG document and keep the rendering order correct.
 *
 * The root node managed by this DOMTreeManager contains two children:
 * a top level group node and a top level defs node. The top level
 * defs node contains the definition of common SVG entities such as
 * the various AlphaComposite rules. Note that other defs can also be
 * created under the top level group, for example to represent
 * gradient or pattern paints.
 * <br>
 * [svg]
 *   |
 *   +-- [defs] Contain generic definitions
 *   +-- [g]    Top level group
 *        |
 *        +-- [defs] Contains definitions specific to rendering
 *        +-- [g]    Group 1
 *        +-- ...
 *        +-- [g]    Group n
 *
 * @author <a href="mailto:vincent.hardy@eng.sun.com">Vincent Hardy</a>
 * @version $Id$
 */
public class DOMTreeManager implements SVGSyntax{
    static final String ERROR_GC_NULL = "gc should not be null";
    static final String ERROR_FACTORY_NULL = "nodeFactory should not be null";
    static final String ERROR_MAXGCOVERRIDES_OUTOFRANGE = "maxGcOverrides should be greater than zero";
    static final String ERROR_EXTENSION_HANDLER_NULL = "extensionHandler should not be null";
    static final String ERROR_IMAGE_HANDLER_NULL = "imageHandler should not be null";
    static final String ERROR_TOP_LEVEL_GROUP_NULL = "topLevelGroup should not be null";
    static final String ERROR_TOP_LEVEL_GROUP_NOT_G = "topLevelGroup should be a group <g>";

    public static final String GENERATOR_COMMENT = "Generated by the Java 2D API Graphics2D SVG Generator, Sun Microsystems Inc.";

    /**
     * XML Document used to create Elements
     */
    Document domFactory;

    /**
     * Used to handler image elements
     */
    ImageHandler imageHandler;

    /**
     * Used to handle Java 2D API extensions
     */
    ExtensionHandler extensionHandler;

    /**
     * Maximum of Graphic Context attributes overrides
     * in children of the current group.
     */
    int maxGCOverrides;

    /**
     * Set of group managers that build groups for
     * this manager
     */
    private Vector groupManagers = new Vector();

    /**
     * Set of definitions that are to be placed at the top of the
     * document tree
     */
    private Set genericDefSet = new HashSet();

    /**
     * Default SVG GraphicContext state
     */
    SVGGraphicContext defaultGC;

    /**
     * Top level group
     */
    private Element topLevelGroup;

    /**
     * Used to convert the Java 2D API graphic context state
     * into the SVG equivalent set of attributes and related
     * definitions
     */
    SVGGraphicContextConverter gcConverter;

    /**
     * Converters used bVy this object to translate graphic context
     * attributes
     */
    private SVGBufferedImageOp filterConverter;

    public SVGBufferedImageOp getFilterConverter(){ return filterConverter; }
    public SVGGraphicContextConverter getGraphicContextConverter(){ return gcConverter; }

    /**
     * Constructor
     * @param gc default graphic context state
     * @param domFactory used to create top level svg root node
     *                    and children group nodes.
     * @param extensionHandler used by SVGConverters to handle custom
     *                         implementations of interfaces such as Paint,
     *                         Composite and BufferedImageOp.
     * @param maxGCOverrides defines how many overrides are allowed
     *                       in children nodes of the current group.
     * @param imageHandler used by SVGConverters to handle image elements.
     */
    public DOMTreeManager(GraphicContext gc,
                          Document domFactory,
                          ExtensionHandler extensionHandler,
                          ImageHandler imageHandler,
                          int maxGCOverrides){
        if(gc == null)
            throw new IllegalArgumentException(ERROR_GC_NULL);

        if(domFactory == null)
            throw new IllegalArgumentException(ERROR_FACTORY_NULL);

        if(extensionHandler == null)
            throw new IllegalArgumentException(ERROR_EXTENSION_HANDLER_NULL);

        if(imageHandler == null)
            throw new IllegalArgumentException(ERROR_IMAGE_HANDLER_NULL);

        if(maxGCOverrides<=0)
            throw new IllegalArgumentException(ERROR_MAXGCOVERRIDES_OUTOFRANGE);

        this.domFactory = domFactory;
        this.maxGCOverrides = maxGCOverrides;
        this.extensionHandler = extensionHandler;
        this.imageHandler = imageHandler;

        // Start with a new Top Level Group
        recycleTopLevelGroup();

        // Build the default GC descriptor
        defaultGC = gcConverter.toSVG(gc);
    }

    /**
     * @param groupManager new DOMGroupManager to add to the list of
     *        managers that collaborate with this tree manager.
     */
    public void addGroupManager(DOMGroupManager groupManager){
        if(groupManager != null)
            groupManagers.addElement(groupManager);
    }

    /**
     * @param groupManager DOMGroupManager to remove from the list of
     *        managers that collaborate with this tree manager
     */
    public void removeGroupManager(DOMGroupManager groupManager){
        if(groupManager != null)
            groupManagers.removeElement(groupManager);
    }

    /**
     * When a group is appended to the tree by this call, all the
     * other group managers are requested to start new groups, in
     * order to preserve the Z-order.
     *
     * @param group new group to be appended to the topLevelGroup
     * @param groupManager DOMTreeManager that produced the group.
     */
    public void appendGroup(Element group, DOMGroupManager groupManager){
        topLevelGroup.appendChild(group);
        int nManagers = groupManagers.size();
        for(int i=0; i<nManagers; i++){
            DOMGroupManager gm = (DOMGroupManager)groupManagers.elementAt(i);
            if( gm != groupManager )
                gm.recycleCurrentGroup();
        }
    }

    /**
     * Reset the state of this object to handler a new topLevelGroup
     */
    private void recycleTopLevelGroup(){
        recycleTopLevelGroup(true);
    }


    /**
     * Reset the state of this object to handler a new topLevelGroup
     */
    private void recycleTopLevelGroup(boolean recycleConverters){
        // First, recycle group managers
        int nManagers = groupManagers.size();
        for(int i=0; i<nManagers; i++){
            DOMGroupManager gm = (DOMGroupManager)groupManagers.elementAt(i);
            gm.recycleCurrentGroup();
        }

        // Create top level group node
        topLevelGroup = domFactory.createElementNS(SVG_NAMESPACE_URI, SVG_G_TAG);

        // Build new converters
        if(recycleConverters){
            filterConverter = new SVGBufferedImageOp(domFactory, extensionHandler);
            gcConverter = new SVGGraphicContextConverter(domFactory, extensionHandler, imageHandler);
        }
    }

    /**
     * Sets the topLevelGroup to the input element. This will throw an exception
     * if the input element is not of type 'g' or if it is null.
     */
    void setTopLevelGroup(Element topLevelGroup){
        if(topLevelGroup == null)
            throw new IllegalArgumentException(ERROR_TOP_LEVEL_GROUP_NULL);

        if(!SVG_G_TAG.equalsIgnoreCase(topLevelGroup.getTagName()))
            throw new IllegalArgumentException(ERROR_TOP_LEVEL_GROUP_NOT_G);

        recycleTopLevelGroup(false);
        this.topLevelGroup = topLevelGroup;
    }

    /**
     * Returns the root element with the generic definitions and
     * the topLevelGroup.
     */
    public Element getRoot(){
        Element svg = domFactory.createElementNS(SVG_NAMESPACE_URI, TAG_SVG);

        // Enable background if required by AlphaComposite convertion
        if(gcConverter.getCompositeConverter().getAlphaCompositeConverter().requiresBackgroundAccess())
            svg.setAttributeNS(null, SVG_ENABLE_BACKGROUND_ATTRIBUTE, VALUE_NEW);

        Comment generatorComment = domFactory.createComment(GENERATOR_COMMENT);
        svg.appendChild(generatorComment);

        // Set default rendering context attributes in node
        Map groupDefaults = defaultGC.getGroupContext();
        Iterator iter = groupDefaults.keySet().iterator();
        while(iter.hasNext()){
            String attrName = (String)iter.next();
            svg.setAttributeNS(null, attrName, (String)groupDefaults.get(attrName));
        }

        svg.appendChild(getGenericDefinitions());
        svg.appendChild(getTopLevelGroup());

        return svg;
    }

    /**
     * @return a defs element that contains all the generic
     *         definitions
     */
    public Element getGenericDefinitions(){
        Element genericDefs = domFactory.createElementNS(SVG_NAMESPACE_URI, SVG_DEFS_TAG);
        Iterator iter = genericDefSet.iterator();
        while(iter.hasNext()){
            genericDefs.appendChild((Element)iter.next());
        }

        genericDefs.setAttributeNS(null, ATTR_ID, ID_PREFIX_GENERIC_DEFS);
        return genericDefs;
    }

    /**
     * @return the extension handler used by this SVGGraphics2D instance
     */
    public ExtensionHandler getExtensionHandler(){
        return extensionHandler;
    }

    /**
     * @param new extension handler this object should use
     */
    void setExtensionHandler(ExtensionHandler extensionHandler){
        this.extensionHandler = extensionHandler;
        filterConverter.setExtensionHandler(extensionHandler);
        gcConverter.setExtensionHandler(extensionHandler);
    }

    /**
     * Invoking this method will return a set of definition element that
     * contain all the definitions referenced by the attributes generated by
     * the various converters. This also resets the converters.
     */
    public Set getDefinitionSet(){
        //
        // The definition set contains all the definitions minus
        // any definition that has been placed in the generic definition set
        //
        Set defSet = gcConverter.getDefinitionSet();
        defSet.removeAll(genericDefSet);
        defSet.addAll(filterConverter.getDefinitionSet());

        // Build new converters
        filterConverter = new SVGBufferedImageOp(domFactory, extensionHandler);
        gcConverter = new SVGGraphicContextConverter(domFactory, extensionHandler, imageHandler);

        return defSet;
    }

    /**
     * Invoking this method will return a reference to the topLevelGroup
     * Element managed by this object. It will also cause this object
     * to start working with a new topLevelGroup.
     *
     * @return top level group
     */
    public Element getTopLevelGroup(){
        boolean includeDefinitionSet = true;
        return getTopLevelGroup(includeDefinitionSet);
    }

    /**
     * Invoking this method will return a reference to the topLevelGroup
     * Element managed by this object. It will also cause this object
     * to start working with a new topLevelGroup.
     *
     * @param includeDefinitionSet if true, the definition set is included and
     *        the converters are reset (i.e., they start with an empty set
     *        of definitions).
     * @return top level group
     */
    public Element getTopLevelGroup(boolean includeDefinitionSet){
        Element topLevelGroup = this.topLevelGroup;

        //
        // Include definition set if requested
        //
        if(includeDefinitionSet){
            Set defSet = getDefinitionSet();
            if(defSet.size() > 0){
                Element defElement = null;

                NodeList defsElements = topLevelGroup.getElementsByTagName(SVG_DEFS_TAG);
                if(defsElements.getLength() > 0)
                    defElement = (Element)defsElements.item(0);

                if(defElement == null){
                    defElement = domFactory.createElementNS(SVG_NAMESPACE_URI, SVG_DEFS_TAG);
                    defElement.setAttributeNS(null, ATTR_ID, SVGIDGenerator.generateID(ID_PREFIX_DEFS));
                    if(topLevelGroup.getChildNodes().getLength() > 0)
                        topLevelGroup.insertBefore(defElement, topLevelGroup.getFirstChild());
                    else
                        topLevelGroup.appendChild(defElement);
                }

                Iterator iter = defSet.iterator();
                while(iter.hasNext())
                    defElement.appendChild((Element)iter.next());
            }
        }

        // If the definition set is included, then the converters have already been
        // recycled in getDefinitionSet. Otherwise, they should not be recycled. So,
        // in all cases, do not recycle the converters here.
        recycleTopLevelGroup(false);

        return topLevelGroup;
    }

    /**
     * Unit testing
     */
    public static void main(String args[]) throws Exception {
        Document domFactory = TestUtil.getDocumentPrototype();

        GraphicContext gc = new GraphicContext(new AffineTransform());
        DOMTreeManager domTreeManager
            = new DOMTreeManager(gc,
                                 domFactory,
                                 new DefaultExtensionHandler(),
                                 new DefaultImageHandler(),
                                 2);

        DOMGroupManager domGroupManager
            = new DOMGroupManager(gc, domTreeManager);

        //
        // Do the following:
        // + Add one rect element
        // + Modify the Paint (modif 1)
        // + Add one ellipse element. Should be under the same group
        // + Modify the Composite (modif 2, ignored, as it does not apply to a group)
        // + Add one circle element. Should be under the same group
        // + Modify the Clip (modif 2bis)
        // + Modify the Transform (modif 3, over limit)
        // + Add one path element: Should be under a new group.
        // + Set the transform to a new transform (new group trigger)
        // + Add a polygon: should be under a new group
        //

        Element rect = domFactory.createElementNS(SVG_NAMESPACE_URI, TAG_RECT);
        Element ellipse = domFactory.createElementNS(SVG_NAMESPACE_URI, SVG_ELLIPSE_TAG);
        Element circle = domFactory.createElementNS(SVG_NAMESPACE_URI, SVG_CIRCLE_TAG);
        Element path = domFactory.createElementNS(SVG_NAMESPACE_URI, TAG_PATH);
        Element polygon = domFactory.createElementNS(SVG_NAMESPACE_URI, TAG_POLYGON);

        rect.setAttributeNS(null, SVG_FILL_ATTRIBUTE, SVG_NONE_VALUE);
        polygon.setAttributeNS(null, ATTR_STROKE, SVG_NONE_VALUE);

        domGroupManager.addElement(rect);

        // Modif 1
        gc.setPaint(Color.red);

        // Ellipse element
        domGroupManager.addElement(ellipse);

        // Modif 2
        gc.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_IN, .5f));

        // Circle element
        domGroupManager.addElement(circle);

        // Modif 2bis
        gc.setClip(new Rectangle(30, 30, 60, 60));

        // Modif 3
        gc.translate(45, 45);

        GraphicContext gc2 = (GraphicContext)gc.clone();
        DOMGroupManager domGroupManager2
            = new DOMGroupManager(gc2, domTreeManager);

        // Path element (should be in a new group)
        domGroupManager2.addElement(path);

        // Modify transform
        gc2.setTransform(AffineTransform.getScaleInstance(45, 50));

        // Polygon element (should be in a new group as well).
        domGroupManager2.addElement(polygon);

        //
        // Now, trace the resulting tree
        //
        Element topLevelGroup = domTreeManager.getTopLevelGroup();
        TestUtil.trace(topLevelGroup, System.out);
    }
}
